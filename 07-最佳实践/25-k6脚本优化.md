# 第25章：k6 脚本优化

## 25.1 内存优化

### 使用 SharedArray

```javascript
// 好的做法：共享数据，节省内存
import { SharedArray } from 'k6/data';

const users = new SharedArray('users', function () {
  return JSON.parse(open('./users.json'));
});

export default function () {
  const user = users[__VU % users.length];
  // 使用用户数据
}

// 不好的做法：每个 VU 都加载数据
export default function () {
  const users = JSON.parse(open('./users.json')); // 重复加载，浪费内存
}
```

### 及时释放大对象

```javascript
export default function () {
  // 使用大对象
  let largeData = fetchLargeData();
  processData(largeData);
  
  // 及时释放
  largeData = null;
  
  // 继续其他操作
}
```

### 控制数据文件大小

```javascript
// 好的做法：只加载需要的数据
const users = new SharedArray('users', function () {
  const allUsers = JSON.parse(open('./users.json'));
  // 只保留必要字段
  return allUsers.map(user => ({
    id: user.id,
    username: user.username,
    // 不加载不需要的字段
  }));
});
```

## 25.2 CPU 优化

### 减少不必要的计算

```javascript
// 好的做法：缓存计算结果
const config = {
  baseUrl: __ENV.BASE_URL || 'https://api.example.com',
};

export default function () {
  // 直接使用配置，不重复计算
  http.get(`${config.baseUrl}/users`);
}

// 不好的做法：每次迭代都计算
export default function () {
  const baseUrl = __ENV.BASE_URL || 'https://api.example.com'; // 重复计算
  http.get(`${baseUrl}/users`);
}
```

### 使用批处理

```javascript
// 好的做法：批处理减少网络往返
const responses = http.batch([
  ['GET', 'https://api.example.com/users'],
  ['GET', 'https://api.example.com/posts'],
  ['GET', 'https://api.example.com/comments'],
]);

// 不好的做法：逐个请求
http.get('https://api.example.com/users');
http.get('https://api.example.com/posts');
http.get('https://api.example.com/comments');
```

### 避免不必要的 JSON 解析

```javascript
// 好的做法：只在需要时解析
export default function () {
  const response = http.get('https://api.example.com/users');
  
  if (response.status === 200) {
    const data = JSON.parse(response.body); // 只在成功时解析
    // 处理数据
  }
}

// 不好的做法：总是解析
export default function () {
  const response = http.get('https://api.example.com/users');
  const data = JSON.parse(response.body); // 即使失败也解析
}
```

## 25.3 网络优化

### 连接复用

```javascript
// k6 自动复用连接，但可以优化请求顺序
export default function () {
  // 好的做法：相关请求放在一起
  http.get('https://api.example.com/users/1');
  http.get('https://api.example.com/users/1/profile');
  
  // 不好的做法：频繁切换域名
  http.get('https://api1.example.com/data');
  http.get('https://api2.example.com/data');
  http.get('https://api1.example.com/data'); // 重复连接
}
```

### 合理设置超时

```javascript
// 好的做法：设置合理的超时时间
const response = http.get('https://api.example.com/data', {
  timeout: '10s', // 根据实际情况设置
});

// 不好的做法：超时时间过长或过短
const response = http.get('https://api.example.com/data', {
  timeout: '60s', // 太长，浪费资源
});
```

### 使用 HTTP/2

```javascript
export const options = {
  httpReq: {
    http2: true, // 启用 HTTP/2，提高性能
  },
};
```

## 25.4 脚本结构优化

### 模块化设计

```javascript
// config.js
export const config = {
  baseUrl: __ENV.BASE_URL || 'https://api.example.com',
  timeout: '10s',
};

// utils.js
export function generateEmail() {
  return `user${Math.random().toString(36).substring(7)}@example.com`;
}

export function sleepRandom(min, max) {
  sleep(Math.random() * (max - min) + min);
}

// test.js
import { config } from './config.js';
import { generateEmail, sleepRandom } from './utils.js';

export default function () {
  // 使用导入的配置和工具函数
}
```

### 函数复用

```javascript
// 好的做法：提取公共函数
function login(username, password) {
  return http.post('https://api.example.com/login', {
    username: username,
    password: password,
  });
}

export default function () {
  const loginRes = login(`user${__VU}`, 'password123');
  // ...
}

// 不好的做法：重复代码
export default function () {
  const loginRes = http.post('https://api.example.com/login', {
    username: `user${__VU}`,
    password: 'password123',
  });
  // 重复的登录代码
}
```

### 减少嵌套

```javascript
// 好的做法：提前返回，减少嵌套
export default function () {
  const response = http.get('https://api.example.com/data');
  
  if (response.status !== 200) {
    return; // 提前返回
  }
  
  const data = JSON.parse(response.body);
  // 处理数据
}

// 不好的做法：深层嵌套
export default function () {
  const response = http.get('https://api.example.com/data');
  if (response.status === 200) {
    try {
      const data = JSON.parse(response.body);
      // 处理数据
    } catch (e) {
      // 错误处理
    }
  }
}
```

## 25.5 性能调优技巧

### 1. 预热时间

```javascript
export const options = {
  stages: [
    { duration: '30s', target: 10 },  // 预热阶段
    { duration: '5m', target: 100 },  // 正式测试
  ],
};
```

### 2. 合理设置思考时间

```javascript
// 好的做法：模拟真实用户行为
sleep(Math.random() * 2 + 1); // 1-3秒随机等待

// 不好的做法：固定等待时间
sleep(1); // 所有用户行为一致
```

### 3. 使用标签分组

```javascript
// 使用标签便于分析和优化
http.get('https://api.example.com/users', {
  tags: { name: 'GetUsers', endpoint: '/users' },
});
```

### 4. 监控自定义指标

```javascript
import { Trend } from 'k6/metrics';

const apiResponseTime = new Trend('api_response_time');

export default function () {
  const start = Date.now();
  const response = http.get('https://api.example.com/data');
  const duration = Date.now() - start;
  
  apiResponseTime.add(duration);
}
```

## 25.6 实际优化案例

### 案例 1：优化数据加载

**优化前**：
```javascript
export default function () {
  const users = JSON.parse(open('./users.json')); // 每次迭代都加载
  const user = users[Math.floor(Math.random() * users.length)];
  // 使用用户数据
}
```

**优化后**：
```javascript
import { SharedArray } from 'k6/data';

const users = new SharedArray('users', function () {
  return JSON.parse(open('./users.json')); // 只加载一次
});

export default function () {
  const user = users[__VU % users.length];
  // 使用用户数据
}
```

### 案例 2：优化请求顺序

**优化前**：
```javascript
export default function () {
  http.get('https://api.example.com/users');
  http.get('https://api.example.com/posts');
  http.get('https://api.example.com/comments');
}
```

**优化后**：
```javascript
export default function () {
  // 使用批处理，减少网络往返
  const responses = http.batch([
    ['GET', 'https://api.example.com/users'],
    ['GET', 'https://api.example.com/posts'],
    ['GET', 'https://api.example.com/comments'],
  ]);
}
```

### 案例 3：优化错误处理

**优化前**：
```javascript
export default function () {
  const response = http.get('https://api.example.com/data');
  const data = JSON.parse(response.body); // 可能失败
  // 处理数据
}
```

**优化后**：
```javascript
export default function () {
  const response = http.get('https://api.example.com/data');
  
  if (response.status !== 200) {
    return; // 提前返回
  }
  
  try {
    const data = JSON.parse(response.body);
    // 处理数据
  } catch (e) {
    console.error('解析失败:', e);
    return;
  }
}
```

## 25.7 性能监控

### 监控脚本性能

```javascript
import { Trend } from 'k6/metrics';

const scriptExecutionTime = new Trend('script_execution_time');

export default function () {
  const start = Date.now();
  
  // 测试逻辑
  http.get('https://api.example.com/data');
  
  const duration = Date.now() - start;
  scriptExecutionTime.add(duration);
}
```

### 识别性能瓶颈

```javascript
import { Trend } from 'k6/metrics';

const httpTime = new Trend('http_time');
const processingTime = new Trend('processing_time');

export default function () {
  const httpStart = Date.now();
  const response = http.get('https://api.example.com/data');
  httpTime.add(Date.now() - httpStart);
  
  const processStart = Date.now();
  const data = JSON.parse(response.body);
  processData(data);
  processingTime.add(Date.now() - processStart);
}
```

## 25.8 总结

k6 脚本优化要点：

✅ **内存优化**：使用 SharedArray，及时释放对象  
✅ **CPU 优化**：减少计算，使用批处理  
✅ **网络优化**：连接复用，合理超时  
✅ **结构优化**：模块化设计，函数复用  
✅ **性能监控**：监控脚本性能，识别瓶颈  

优化脚本可以提高测试效率和准确性！

---

**下一章**：[第26章：错误处理与调试](./26-错误处理与调试.md)

