# 第26章：错误处理与调试

## 26.1 错误处理策略

### 基本错误处理

```javascript
import http from 'k6/http';

export default function () {
  const response = http.get('https://api.example.com/data');
  
  // 检查响应是否存在
  if (!response) {
    console.error('请求失败：响应为空');
    return;
  }
  
  // 检查状态码
  if (response.status === 0) {
    console.error('请求失败：连接失败或超时');
    return;
  }
  
  // 检查 HTTP 状态码
  if (response.status !== 200) {
    console.error(`请求失败：状态码 ${response.status}`);
    return;
  }
  
  // 处理成功响应
  try {
    const data = JSON.parse(response.body);
    // 处理数据
  } catch (e) {
    console.error('JSON 解析失败:', e);
  }
}
```

### 分层错误处理

```javascript
function handleHttpError(response, context) {
  if (!response) {
    console.error(`${context}: 响应为空`);
    return false;
  }
  
  if (response.status === 0) {
    console.error(`${context}: 连接失败`);
    return false;
  }
  
  if (response.status >= 400) {
    console.error(`${context}: HTTP 错误 ${response.status}`);
    return false;
  }
  
  return true;
}

export default function () {
  const response = http.get('https://api.example.com/data');
  
  if (!handleHttpError(response, '获取数据')) {
    return;
  }
  
  // 继续处理
}
```

## 26.2 重试机制

### 简单重试

```javascript
function httpGetWithRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    const response = http.get(url);
    
    if (response.status === 200) {
      return response;
    }
    
    if (i < maxRetries - 1) {
      sleep(1); // 等待1秒后重试
    }
  }
  
  return null;
}

export default function () {
  const response = httpGetWithRetry('https://api.example.com/data');
  
  if (!response) {
    console.error('所有重试都失败');
  }
}
```

### 指数退避重试

```javascript
function httpGetWithExponentialBackoff(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    const response = http.get(url);
    
    if (response.status === 200) {
      return response;
    }
    
    if (i < maxRetries - 1) {
      const waitTime = Math.pow(2, i); // 1s, 2s, 4s
      sleep(waitTime);
    }
  }
  
  return null;
}
```

### 条件重试

```javascript
function httpGetWithConditionalRetry(url) {
  const maxRetries = 3;
  
  for (let i = 0; i < maxRetries; i++) {
    const response = http.get(url);
    
    // 只在 5xx 错误时重试
    if (response.status >= 500 && response.status < 600) {
      if (i < maxRetries - 1) {
        sleep(Math.pow(2, i));
        continue;
      }
    }
    
    return response;
  }
  
  return null;
}
```

## 26.3 日志记录

### 基本日志

```javascript
export default function () {
  console.log(`VU ${__VU} - Iteration ${__ITER} - 开始`);
  
  const response = http.get('https://api.example.com/data');
  
  if (response.status === 200) {
    console.log(`VU ${__VU} - 请求成功`);
  } else {
    console.error(`VU ${__VU} - 请求失败: ${response.status}`);
  }
}
```

### 结构化日志

```javascript
function log(level, message, data = {}) {
  const timestamp = new Date().toISOString();
  const logEntry = {
    timestamp: timestamp,
    level: level,
    vu: __VU,
    iteration: __ITER,
    message: message,
    ...data,
  };
  
  if (level === 'error') {
    console.error(JSON.stringify(logEntry));
  } else {
    console.log(JSON.stringify(logEntry));
  }
}

export default function () {
  log('info', '开始请求', { url: 'https://api.example.com/data' });
  
  const response = http.get('https://api.example.com/data');
  
  if (response.status === 200) {
    log('info', '请求成功', { status: response.status });
  } else {
    log('error', '请求失败', { status: response.status });
  }
}
```

### 日志级别控制

```javascript
const LOG_LEVEL = __ENV.LOG_LEVEL || 'INFO';

function log(level, message) {
  const levels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3 };
  const currentLevel = levels[LOG_LEVEL] || 1;
  const messageLevel = levels[level] || 1;
  
  if (messageLevel >= currentLevel) {
    console.log(`[${level}] ${message}`);
  }
}

export default function () {
  log('DEBUG', '详细调试信息');
  log('INFO', '一般信息');
  log('WARN', '警告信息');
  log('ERROR', '错误信息');
}
```

## 26.4 调试技巧

### 使用 console.log

```javascript
export default function () {
  console.log('=== 调试信息 ===');
  console.log(`VU: ${__VU}`);
  console.log(`Iteration: ${__ITER}`);
  
  const response = http.get('https://api.example.com/data');
  
  console.log('响应状态:', response.status);
  console.log('响应时间:', response.timings.duration);
  console.log('响应体长度:', response.body.length);
}
```

### 使用断点（通过日志）

```javascript
export default function () {
  const DEBUG = __ENV.DEBUG === 'true';
  
  if (DEBUG) {
    console.log('=== 断点 1: 开始 ===');
  }
  
  const response = http.get('https://api.example.com/data');
  
  if (DEBUG) {
    console.log('=== 断点 2: 请求完成 ===');
    console.log('响应:', response.body.substring(0, 100));
  }
  
  const data = JSON.parse(response.body);
  
  if (DEBUG) {
    console.log('=== 断点 3: 数据解析完成 ===');
    console.log('数据:', JSON.stringify(data, null, 2));
  }
}
```

### 条件调试

```javascript
export default function () {
  const DEBUG_VU = __ENV.DEBUG_VU ? parseInt(__ENV.DEBUG_VU) : null;
  
  if (DEBUG_VU === null || __VU === DEBUG_VU) {
    console.log(`[VU ${__VU}] 调试模式开启`);
    
    const response = http.get('https://api.example.com/data');
    console.log(`[VU ${__VU}] 响应:`, response.status);
  } else {
    // 正常执行，不输出日志
    http.get('https://api.example.com/data');
  }
}
```

## 26.5 问题排查方法

### 1. 检查网络连接

```javascript
export function setup() {
  // 检查 API 是否可达
  const healthCheck = http.get('https://api.example.com/health');
  
  if (healthCheck.status !== 200) {
    throw new Error('API 不可用');
  }
  
  return { ready: true };
}
```

### 2. 检查响应内容

```javascript
export default function () {
  const response = http.get('https://api.example.com/data');
  
  console.log('状态码:', response.status);
  console.log('响应头:', JSON.stringify(response.headers));
  console.log('响应体前100字符:', response.body.substring(0, 100));
  
  if (response.status !== 200) {
    console.error('完整响应体:', response.body);
  }
}
```

### 3. 检查时间信息

```javascript
export default function () {
  const start = Date.now();
  const response = http.get('https://api.example.com/data');
  const duration = Date.now() - start;
  
  console.log('总耗时:', duration, 'ms');
  console.log('连接时间:', response.timings.connecting, 'ms');
  console.log('等待时间:', response.timings.waiting, 'ms');
  console.log('接收时间:', response.timings.receiving, 'ms');
}
```

### 4. 检查错误类型

```javascript
export default function () {
  const response = http.get('https://api.example.com/data');
  
  if (response.status === 0) {
    console.error('错误类型: 连接失败或超时');
  } else if (response.status >= 400 && response.status < 500) {
    console.error('错误类型: 客户端错误');
    console.error('错误详情:', response.body);
  } else if (response.status >= 500) {
    console.error('错误类型: 服务器错误');
    console.error('错误详情:', response.body);
  }
}
```

## 26.6 常见错误处理模式

### 模式 1：优雅降级

```javascript
export default function () {
  // 尝试主要接口
  let response = http.get('https://api.example.com/primary');
  
  // 如果失败，尝试备用接口
  if (response.status !== 200) {
    console.warn('主要接口失败，使用备用接口');
    response = http.get('https://api.example.com/fallback');
  }
  
  if (response.status === 200) {
    // 处理响应
  }
}
```

### 模式 2：错误收集

```javascript
const errors = [];

export default function () {
  const response = http.get('https://api.example.com/data');
  
  if (response.status !== 200) {
    errors.push({
      vu: __VU,
      iteration: __ITER,
      status: response.status,
      timestamp: new Date().toISOString(),
    });
  }
}

export function teardown(data) {
  if (errors.length > 0) {
    console.error('错误汇总:', JSON.stringify(errors, null, 2));
  }
}
```

### 模式 3：错误率监控

```javascript
import { Rate } from 'k6/metrics';

const errorRate = new Rate('custom_error_rate');

export default function () {
  const response = http.get('https://api.example.com/data');
  
  const isError = response.status !== 200;
  errorRate.add(!isError);
  
  if (isError) {
    console.error(`VU ${__VU}: 请求失败 - ${response.status}`);
  }
}
```

## 26.7 调试工具

### k6 调试选项

```bash
# 详细输出
k6 run --verbose script.js

# 只运行一次迭代
k6 run --iterations 1 script.js

# 使用单个 VU
k6 run --vus 1 --iterations 1 script.js
```

### 输出调试信息

```javascript
export const options = {
  vus: 1,
  iterations: 1,
};

export default function () {
  console.log('=== 调试模式 ===');
  // 调试代码
}
```

## 26.8 总结

错误处理与调试要点：

✅ **错误处理**：检查响应、状态码、异常  
✅ **重试机制**：简单重试、指数退避、条件重试  
✅ **日志记录**：结构化日志、日志级别控制  
✅ **调试技巧**：console.log、条件调试、断点  
✅ **问题排查**：网络检查、响应检查、时间分析  

良好的错误处理和调试能力，可以提高测试脚本的可靠性！

---

**下一章**：[第28章：高级主题](./08-面试与进阶/28-高级主题.md)

